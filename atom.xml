<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[HttpException]]></title>
  <link href="https://www.httpexception.com/atom.xml" rel="self"/>
  <link href="https://www.httpexception.com/"/>
  <updated>2018-09-14T22:58:47-07:00</updated>
  <id>https://www.httpexception.com/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Smart Pointers in Modern C++]]></title>
    <link href="https://www.httpexception.com/smart-pointers-in-modern-cpp.html"/>
    <updated>2018-09-14T01:25:04-07:00</updated>
    <id>https://www.httpexception.com/smart-pointers-in-modern-cpp.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><code>C++11</code>: <del>auto_ptr</del>, <code>unique_ptr</code>, <code>shared_ptr</code>, <code>weak_ptr</code></p>
</blockquote>

<p>Smart pointers can do virtually everything raw pointers can, but with far fewer opportunities for error.<br/>
<span id="more"></span><!-- more --></p>

<h2 id="toc_0"><em>unique_ptr</em></h2>

<p>Use <em>unique_ptr</em> when you want to have <strong><em>single ownership</em></strong> (exclusive) of resource. When that <em>unique_ptr</em> is destructed, the resource is automatically released.</p>

<h3 id="toc_1">custom deleter</h3>

<pre><code class="language-cpp">auto deleter = [](A* a){ ... delete a;} //lambda
unique_ptr&lt;A, decltype(deleter)&gt; A(new A, deleter)
</code></pre>

<h3 id="toc_2">move semantics</h3>

<p>Unlike <del>auto_ptr</del>, copy assignment is not allowed for <em>unique_ptr</em>. Ownership is truly unique and safe. <em>unique_ptr</em> can be moved using the new move semantics:</p>

<pre><code class="language-cpp">unique_ptr&lt;A&gt; ptr1 (new A);
unique_ptr&lt;A&gt; ptr2 = std::move(ptr1);
</code></pre>

<h2 id="toc_3"><em>shared_ptr</em></h2>

<p>A <em>shared_ptr</em> is a container for a raw pointer. It is a <strong><em>reference counting ownership model</em></strong> i.e. it maintains the reference count of its contained pointer in cooperation with all copies of the <em>shared_ptr</em>. So, the counter is incremented each time a new <em>shared_ptr</em> points to the resource and decremented when the <em>shared_ptr</em> is destructed. An object will not be destroyed until all copies of <em>shared_ptr</em> have been destructed. So, we should use <em>shared_ptr</em> when we want to assign one raw pointer to multiple owners.</p>

<h3 id="toc_4"><em>enable_shared_from_this</em></h3>

<p>It enables you to get a valid <em>shared_ptr</em> instance to <em>this</em>, when all you have is <em>this</em>. <strong>Without</strong> it, you would have <strong>no way</strong> of getting a <em>shared_ptr</em> to this, unless you already had one as a member.</p>

<pre><code class="language-cpp">class A: public enable_shared_from_this&lt;A&gt;
{
public:
    shared_ptr&lt;A&gt; getMe() { return shared_from_this(); }
}
</code></pre>

<p>The method <em>getMe()</em> returns a valid <em>shared_ptr</em>. Note that you cannot simply do <del>shared_ptr&lt;A&gt; getMe() { return shared_ptr&lt;A&gt;(this); }</del>. Because the returned <em>shared_ptr</em> will have a different reference counting control, which will end up holding a dangling reference when the object is deleted.</p>

<h2 id="toc_5"><em>weak_ptr</em></h2>

<p>A <em>weak_ptr</em> is created as a copy of <em>shared_ptr</em>. It provides <strong>access</strong> to an object that is owned by one or more <em>shared_ptr</em>, but <strong>does not</strong> participate in reference counting. The existence or destruction of <em>weak_ptr</em> has no effect on the <em>shared_ptr</em> or its other copies. It is required in some cases to break <strong><em>circular references</em></strong> between <em>shared_ptr</em> instances.</p>

<h3 id="toc_6">circular dependency of <em>shared_ptr</em></h3>

<p>Consider a scenario where we have two objects A and B. <code>A</code> has <code>shared_ptr&lt;B&gt; b</code> and <code>B</code> has <code>shared_ptr&lt;A&gt; a</code>. Hence, <em>use_count</em> will <strong>never reach zero</strong> and they will never get deleted.</p>

<h3 id="toc_7">basic uses of <em>weak_ptr</em></h3>

<pre><code class="language-cpp">// created as a copy of shared_ptr
std::weak_ptr&lt;Widget&gt; w_ptr(s_ptr);

// check if w_ptr is valid
if (!w_ptr.expired()) {
    // do something
}

// lock() creates a new shared_ptr that shares
// ownership of the managed object.
// If there is no managed object,
// the returned shared_ptr is also empty.
// i.e. expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)
if (auto s_ptr_2 = w_ptr.lock()) {
    // do something
} else {
    // do something
}
</code></pre>

<h2 id="toc_8"><em>make_unique</em> and <em>make_shared</em></h2>

<h3 id="toc_9">potential memory leak</h3>

<blockquote>
<p><del>processWidget(shared_ptr&lt;Widget&gt;(new Widget), getSomething());</del></p>
</blockquote>

<p>It depends on compiler, if it firstly calls <em>new Widget</em>, then <em>getSomething()</em> and <em>getSomething()</em> throws an <strong>exception</strong>, <em>Widget</em> is leaked.</p>

<blockquote>
<p>processWidget(make_shared&lt;Widget&gt;(), getSomething());</p>
</blockquote>

<p>The correct way is as above.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Task Scheduler]]></title>
    <link href="https://www.httpexception.com/task-scheduler.html"/>
    <updated>2018-09-12T22:47:21-07:00</updated>
    <id>https://www.httpexception.com/task-scheduler.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><code>leetcode 621</code> <code>heap</code> <code>priority queue</code></p>
</blockquote>

<p>Given a letter (A to Z) array representing tasks. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.</p>

<p>However, there is a non-negative cooling interval <strong>n</strong> that means between <strong>two same tasks</strong>, there must be at least n intervals that CPU are doing different tasks or just be idle.</p>

<p>You need to return the <strong>least</strong> number of intervals the CPU will take to finish all the given tasks.<br/>
<span id="more"></span><!-- more --><br/>
<strong>Example</strong></p>

<p><code>tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</code> -&gt; <code>8</code></p>

<p><code>A</code>-<code>B</code>-<code>#</code>-<code>A</code>-<code>B</code>-<code>#</code>-<code>A</code>-<code>B</code></p>

<h2 id="toc_0">Solution</h2>

<p>Use a max-heap to place most frequent elements in the first priority.</p>

<pre><code class="language-python">def leastInterval(tasks, n):
    n += 1
    ret = 0
    d = collections.Counter(tasks)
    heap = [-c for c in d.values()] # max-heap build trick
    heapq.heapify(heap)
    while heap:
        temp = []
        count = 0
        for _ in range(n):
            if heap:
                c = heapq.heappop(heap)
                count += 1
                if c &lt; -1:
                    temp.append(c + 1)
        for item in temp:
            heapq.heappush(heap, item)
        ret += n if heap else count
    return ret
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Evaluate Reverse Polish Notation]]></title>
    <link href="https://www.httpexception.com/evaluate-reverse-polish-notation.html"/>
    <updated>2018-09-12T21:18:52-07:00</updated>
    <id>https://www.httpexception.com/evaluate-reverse-polish-notation.html</id>
    <content type="html"><![CDATA[
<blockquote>
<p><code>leetcode 150</code> <code>stack</code></p>
</blockquote>

<p>Evaluate the value of an arithmetic expression in <strong><em>Reverse Polish Notation</em></strong>.</p>

<p>Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>. Each operand may be an integer or another expression.<br/>
<span id="more"></span><!-- more --><br/>
<strong>Examples</strong></p>

<pre><code class="language-python">[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;] -&gt; ((2 + 1) * 3) -&gt; 9
[&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;] -&gt; (4 + (13 / 5)) -&gt; 6

[&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
-&gt; ((10 * (6 / ((9 + 3) * (-11)))) + 17) + 5 -&gt; 22
</code></pre>

<h2 id="toc_0">Solution</h2>

<p>Use stack to store ints, pop and eval two ints when get an operator.</p>

<p>Time O(n), Space O(n).</p>

<pre><code class="language-python">def evalRPN(tokens):
    stack = []
    for t in tokens:
        if t not in &#39;+-*/&#39;:
            stack.append(int(t))
        else:
            r, l = stack.pop(), stack.pop()
            if &#39;+&#39; == t: stack.append(l+r)
            elif &#39;-&#39; == t: stack.append(l-r)
            elif &#39;*&#39; == t: stack.append(l*r)
            else: stack.append(int(float(l)/r))
    return stack.pop()
</code></pre>

]]></content>
  </entry>
  
</feed>
